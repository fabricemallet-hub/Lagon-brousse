rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * CORE PHILOSOPHY
     * This ruleset implements a hybrid security model: a strict User-Ownership model for private profiles 
     * and a Public-Read model for environmental and geographical data (Communes). 
     * 
     * DATA STRUCTURE
     * 1. Public Data: All environmental data (tides, weather, swell, etc.) is organized under /communes/{communeId}.
     * 2. Private Data: User-specific settings and subscriptions are stored in /users/{userId}/profile.
     * 
     * KEY SECURITY DECISIONS
     * - Public Data: Read access is open to all users to allow for wide availability of weather/tide info.
     * - System-Managed Content: Since the Commune-related entities (Weather, Tides, etc.) represent 
     *   system-provided data, write access is restricted. Developers should use a Service SDK or 
     *   explicit Admin roles for updates.
     * - Identity Verification: All private data access is strictly gated by the authenticated user's UID.
     * 
     * PROTOTYPING MODE
     * This ruleset focuses on "Who" can access data (Authorization) rather than "What" the data looks like (Schema).
     * It enforces relationship integrity (e.g., matching IDs) but permits flexible data shapes for rapid iteration.
     */

    // --- Helper Functions ---

    /** @description Checks if the request is from an authenticated user. */
    function isSignedIn() {
      return request.auth != null;
    }

    /** @description Checks if the authenticated user's UID matches the provided userId. */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /** @description Checks if the user is the owner and the document exists (for updates/deletes). */
    function isExistingOwner(userId) {
      return resource != null && isOwner(userId);
    }

    // --- Collection Rules ---

    /**
     * @description Top-level geographical data for New Caledonia.
     * @path /communes/{communeId}
     * @allow (get) Any user can fetch a specific commune.
     * @deny (create) Unauthenticated or unauthorized users cannot create communes.
     * @principle Public read-only access for core reference data.
     */
    match /communes/{communeId} {
      allow get, list: if true;
      
      // CRITICAL: Cannot implement owner-only writes. The 'Commune' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner or admin validation once the schema is updated.

      /**
       * @description Meteorological predictions for a specific commune and day.
       * @path /communes/{communeId}/dailyWeather/{dailyWeatherId}
       * @allow (list) Any user can browse daily weather for a commune.
       * @deny (update) No public user can modify meteorological data.
       * @principle Public consumption of system-provided environmental data.
       */
      match /dailyWeather/{dailyWeatherId} {
        allow get, list: if true;
        allow create, update, delete: if false; // TODO: Restrict to system/admin writers.
      }

      /**
       * @description Predicted tide events (High/Low) and current strengths.
       * @path /communes/{communeId}/tideObservations/{tideObservationId}
       * @allow (get) Public access to tide schedules.
       * @deny (delete) Users cannot delete tide records.
       */
      match /tideObservations/{tideObservationId} {
        allow get, list: if true;
        allow create, update, delete: if false; // TODO: Restrict to system/admin writers.
      }

      /**
       * @description Detailed swell and wave height info for lagoon and reef.
       * @path /communes/{communeId}/swellConditions/{swellConditionId}
       * @allow (list) Public list of sea conditions.
       * @deny (create) Direct client-side creation is blocked.
       */
      match /swellConditions/{swellConditionId} {
        allow get, list: if true;
        allow create, update, delete: if false; // TODO: Restrict to system/admin writers.
      }

      /**
       * @description Sun/Moon times and lunar phases for agricultural/fishing use.
       * @path /communes/{communeId}/dailyAstronomy/{dailyAstronomyId}
       * @allow (get) Public access to astronomical data.
       * @deny (update) Data is read-only for clients.
       */
      match /dailyAstronomy/{dailyAstronomyId} {
        allow get, list: if true;
        allow create, update, delete: if false; // TODO: Restrict to system/admin writers.
      }

      /**
       * @description Fishing success scores and recommendations.
       * @path /communes/{communeId}/fishingForecasts/{fishingForecastId}
       * @allow (list) Public users can see if today is good for fishing.
       */
      match /fishingForecasts/{fishingForecastId} {
        allow get, list: if true;
        allow create, update, delete: if false; // TODO: Restrict to system/admin writers.
      }

      /**
       * @description Traditional and lunar-based agricultural planting tips.
       * @path /communes/{communeId}/agriculturalGuidance/{agriculturalGuidanceId}
       * @allow (get) Any user can view agricultural advice.
       */
      match /agriculturalGuidance/{agriculturalGuidanceId} {
        allow get, list: if true;
        allow create, update, delete: if false; // TODO: Restrict to system/admin writers.
      }
    }

    /**
     * @description User-specific settings, subscriptions, and favorites.
     * @path /users/{userId}/profile
     * @allow (create) User 'XYZ' can create their own profile if the doc ID is 'XYZ'.
     * @deny (get) User 'ABC' cannot read User 'XYZ's profile.
     * @principle Strict ownership for private data. Enforces ID consistency between path and document data.
     */
    match /users/{userId}/profile {
      allow get, list: if isOwner(userId);
      
      // On create: Ensure the internal 'id' matches the auth UID and the path.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      
      // On update: Ensure the 'id' field remains immutable and user owns the doc.
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      
      allow delete: if isExistingOwner(userId);
    }
  }
}